<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>函数节流</title>
	<style>
		em{
			color:red;
			font-size:18px;
		}
		a{
			text-decoration:none;
			color:rgba(0,0,255,0.6);
		}
	</style>
</head>
<body>
	<section>
		<h3>什么是函数节流</h3>
		<h4>1.概念</h4>
		<p>简单来说，就是让一个函数无法在很短的时间间隔内连续调用，只有当上一次函数执行后过了你规定的时间间隔，才能进行下一次该函数的调用</p>
		<h4>2.原理</h4>
		<p>用定时器，当触发一个事件时，先setTimout让这个事件延迟一会再执行，如果在这个时间间隔内又触发了事件，那我们就clear掉原来的定时器，再setTimeout一个新的定时器延迟一会执行。</p>
	</section>
	<hr>
	<section>
		<h3>为什么要使用函数节流</h3>
		<p>问题： 在浏览器 DOM 事件里面，有一些事件会随着用户的操作不间断触发。比如：重新调整浏览器窗口大小（resize），浏览器页面滚动（scroll），鼠标移动（mousemove）。也就是说用户在触发这些浏览器操作的时候，如果脚本里面绑定了对应的事件处理方法，这个方法就不停的触发。
		这并不是我们想要的，因为有的时候如果事件处理方法比较庞大，DOM 操作比如复杂，还不断的触发此类事件就会造成性能上的损失，导致用户体验下降（UI 反映慢、浏览器卡死等），而函数节流产生，就是为了改善这些问题的</p>
	</section>
	<hr>
	<section>
		<h3>怎么使用函数节流</h3>
		<h4>实例1：对改变浏览器的窗口大小的事件进行优化</h4>
		<script>
		//以下代码分段执行
			//#问题，打开控制台，看改变窗口大小时，resizehandler的执行频率
		/*
			var n=0;
	       	function resizehandler(){
	           console.log(new Date().getTime());
	           console.log(++n);
	       	}
	       	window.onresize=resizehandler;
		*/
			
	      //#改进1,不难发现这个方案会发生警告：ReferenceError: reference to undefined property "tId"，但确实达到了预期的效果
	    /*
	      	var n=0;
	      	function resizehandler(){
	           console.log(new Date().getTime());
	           console.log(++n);
	       	}
			//在《JavaScript高级程序设计》中有专门应对此问题的函数节流
	       	function throttle(method,context){
       	           clearTimeout(method.tId);
       	           method.tId=setTimeout(function(){
       	               method.call(context);
       	           },500);
	       	}

	       	window.onresize=function(){
	       		throttle(resizehandler,window)
	       	}
		*/
	
	      //#改进2，这个改进没有警告了，但是还有问题，如果用户不断的 resize 浏览器窗口大小，在这段过程延迟处理函数一次都不会执行
	    /*
	      var n=0;
	      	function resizehandler(){
	           console.log(new Date().getTime());
	           console.log(++n);
	       	}
	       	//用一个闭包函数（throttle节流）把 timer 放在内部并且返回延时处理函数，这样以来 timer 变量对外是不可见的，但是内部延时函数触发时还可以访问到 timer 变量。
	       	function throttle(method,delay){
	            var timer=null;
	            return function(){
	                var context=this, args=arguments;
	                clearTimeout(timer);
	                timer=setTimeout(function(){
	                    method.apply(context,args);
	                },delay);
	            }
        	}
	       	 window.onresize=throttle(resizehandler,500);
	    */
	   
	   		//改进3，当用户触发 resize 的时候应该 在某段时间 内至少触发一次，既然是在某段时间内，那么这个判断条件就可以取当前的时间毫秒数，每次函数调用把当前的时间和上一次调用时间相减，然后判断差值如果大于 某段时间 就直接触发，否则还是走 timeout 的延迟逻辑
	   	/*
	   		var n=0;
	   			function resizehandler(){
	   		     console.log(new Date().getTime());
	   		     console.log(++n);
	   		 	}
	   		var throttle = function (fn, delay, atleast) {
	   		    var timer = null;
	   		    var previous = null;

	   		    return function () {
	   		        var now = +new Date();
	   		        if ( !previous ){
	   		        	previous = now;
	   		        }
	   		        if ( now - previous > atleast ) {
	   		            fn();
	   		            // 重置上一次开始时间为本次结束时间
	   		            previous = now;
	   		        } else {
	   		            clearTimeout(timer);
	   		            timer = setTimeout(function() {
	   		                fn();
	   		            }, delay);
	   		        }
	   		    }
	   		};
	   		window.onresize=throttle(resizehandler,500,2000);
	   	*/
		</script>
		<h4>实例2:模拟一个窗口 scroll 时节流的场景</h4>
		<script>
		/*
			var count = 0;
			function testFn() {
				console.log('testFN 被调用了 ' + ++count + '次') ;
			}
			var throttle = function (fn, delay, atleast) {
			        var timer = null;
			        var previous = null;

			        return function () {
			            var now = +new Date();

			            if ( !previous ) previous = now;
			            if ( atleast && now - previous > atleast ) {
			                fn();
			                // 重置上一次开始时间为本次结束时间
			                previous = now;
			                clearTimeout(timer);
			            } else {
			                clearTimeout(timer);
			                timer = setTimeout(function() {
			                    fn();
			                    previous = null;
			                }, delay);
			            }
			        }
			    };
			    //window.onscroll = throttle(testFn, 200);
			    window.onscroll = throttle(testFn, 500, 1000);
			*/
		</script>
	</section>
</body>
</html>