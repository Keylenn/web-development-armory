<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>回调函数</title>
	<style>
		em{
			color:red;
			font-size:18px;
		}
		a{
			text-decoration:none;
			color:rgba(0,0,255,0.6);
		}
	</style>
</head>
<body>
	<section>
		<h3>什么是回调函数</h3>
		<h4>1.概念</h4>
		<p>一个回调函数，也被称为高阶函数，是一个被<em>作为参数传递</em>给另一个函数（在这里我们把另一个函数叫做“otherFunction”）的函数，回调函数<em>在otherFunction中被调用</em>。一个回调函数本质上是一种编程模式（为一个常见问题创建的解决方案），因此，使用回调函数也叫做回调模式。</p>
		<h4>2.易错解析</h4>
		<p>1）回调函数是闭包？</p>
		<p>都能够我们将一个毁掉函数作为变量传递给另一个函数时，这个毁掉函数在包含它的函数内的某一点执行，就好像这个回调函数是在包含它的函数中定义的一样。这意味着回调函数本质上是一个闭包。本质上，如果将函数当做第一级的值类型并到处传递，你就会看到闭包在这些函数中的应用，在定时器，事件监听器，AJAX请求，跨窗口通信，WebWorkers等任务中，只要使用了回调函数，实际上就是在使用闭包</p>
		<p>2）回调函数如何传参？</p>
		<script>
			//方法1：将回调函数的参数作为与回调函数同等级的参数进行传递
			function caback1(name){
				console.log(name);
			}
			function func1(callback,name){
				callback(name);
			}
			func1(caback1,'Marry');
			//方法2：回调函数的参数在调用回调函数内部创建
			function caback2(name){
				console.log(name);
			}
			function func2(callback){
				var name="Semon";
				callback(name);
			}
			func2(caback2);
		</script>
		<p>3）回调函数原理</p>
		<pre>
		我现在出发，到了通知你”
		这是一个异步的流程，“我出发”这个过程中（函数执行），“你”可以去做任何事，“到了”（函数执行完毕）“通知你”（回调）进行之后的流程
		</pre>
		<p>4）在执行之前确保回调函数是一个函数</p>
		<script>
		/*
			function fun3(callback){
				//确保callback是一个函数    
				if(typeof callback === "function"){
				    //调用它，既然我们已经确定了它是可调用的
				      callback();
				}
			}
		*/
		</script>
	</section>
	<hr>
	<section>
		<h3>为什么要使用回调函数</h3>
		<p>1）.当函数的实现过程非常漫长，你是选择等待函数完成处理，还是使用回调函数进行<em>异步处理</em>呢？这种情况下，使用回调函数变得至关重要，例如：AJAX请求。若是使用回调函数进行处理，代码就可以继续进行其他任务，而无需空等。</p>
		<p>2）.节省全局变量，有助于根据需求调整代码，提升性能</p>
		<pre>
		应用举例：JQuey、异步调用（例如AJAX请求、读取文件，进行HTTP请求，等等）、时间监听器/处理器、setTimeout和setInterval方法

		</pre>
	</section>
	<hr>
	<section>
		<h3>怎么使用回调函数</h3>
		<h4>1.使用命名或匿名函数作为回调</h4>
		<p>实例：有函数（假设为a,b），实现函数a传入任意三个参数，分别乘以2后加上函数b的参数的个数，结果以数组形式输出</p>
		<script>
		/*
			//使用命名函数b作为回调
			function b(){
				return arguments.length;
			}
			function a(a,b,c,callback){
				var arr=[];
				for(var i=0;i<3;i++){
					if(typeof callback==="function"){
						arr[i]=arguments[i]*2+callback(1,2,'x');//在这里要用到函数b，回调
					}
				}
				return arr;
			}
			console.log(a(1,2,3,b));
		*/
		/*
			//使用匿名函数作为回调
			function a(a,b,c,callback){
				var arr=[];
				for(var i=0;i<3;i++){
					if(typeof callback==="function"){
						arr[i]=arguments[i]*2+callback(1,2,'x');//在这里要用到匿名函数，回调
					}
				}
				return arr;
			}
			console.log(a(1,2,3,function(){return arguments.length;}));
		*/
		</script>
		<h4>2.使用Call和Apply函数</h4>
		<script>
		/*
			//call()
			function Thing(name) {
				this.name = name;
			}
			Thing.prototype.doSomething = function(callback) {
				callback.call(this);
			}
			  
			function foo() {
				console.log(this.name);
			}
			  
			var t = new Thing('Joe');
			t.doSomething(foo); 
		*/
		/*
			//apply()
			function Thing(name) {
				this.name = name;
			}
			Thing.prototype.doSomething = function(callback) {
				callback.apply(this, ['Hi', 3, 2, 1]);
			} 
			function foo(salutation, three, two, one) {
				console.log(salutation + " " + this.name + " – " + three + " " + two + " " + one);
			} 
			var t = new Thing('Joe');
			t.doSomething(foo);
		*/
		</script>
		<h4>3.callback hell问题</h4>
		<p>在执行异步代码时，无论以什么顺序简单的执行代码，经常情况会变成许多层级的回调函数堆积以致代码变成下面的情形，这种情形叫callback hell。</p>
		<pre>
		var p_client = new Db('integration_tests_20', new Server("127.0.0.1", 27017, {}), {'pk':CustomPKFactory});
		    p_client.open(function(err, p_client) {
		        p_client.dropDatabase(function(err, done) {
		            p_client.createCollection('test_custom_key', function(err, collection) {
		                collection.insert({'a':1}, function(err, docs) {
		                    collection.find({'_id':new ObjectID("aaaaaaaaaaaa")}, function(err, cursor) {
		                        cursor.toArray(function(err, items) {
		                            test.assertEquals(1, items.length);

		                            // Let's close the db
		                            p_client.close();
		                        });
		                    });
		                });
		            });
		        });
		    });
		</pre>
		<p>解决方案：<a href="#promise">Promise</a>--解决回调的深层嵌套</p>
	</section>
	<section>
		<pre name="promise" id="promise">
			Promise：
				概念：ES6 原生提供了 Promise 对象，所谓 Promise，就是一个对象，
				用来传递异步操作的消息。它代表了某个未来才会知道结果的事件（通
				常是一个异步操作），并且这个事件提供统一的 API，可供进一步处理

				特点：
					（1）对象的状态不受外界影响。Promise 对象代表一个异步操作，
					有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）
					和 Rejected（已失败）。只有异步操作的结果，可以决定当前是哪
					一种状态，任何其他操作都无法改变这个状态。这也是 Promise 
					这个名字的由来，它的英语意思就是「承诺」，表示其他手段无法改变。

					（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise
					对象的状态改变，只有两种可能：从 Pending 变为 Resolved 和从 Pending 
					变为 Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直
					保持这个结果。就算改变已经发生了，你再对 Promise 对象添加回调函数，
					也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果
					你错过了它，再去监听，是得不到结果的。
												<a href="promise.html" target="_blank">更多</a>
		</pre>
	</section>
</body>
</html>