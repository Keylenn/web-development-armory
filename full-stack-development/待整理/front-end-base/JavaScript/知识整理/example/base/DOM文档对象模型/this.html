<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>详解this</title>
	<style>
		em{
			color:red;
			font-size: 18px;
		}
		a{
			text-decoration:none;
			color:rgba(0,0,255,0.7);
		}
	</style>
</head>
<body>
	<section>
		<h3>1.this是什么</h3>
		<p>this是函数<em>被调用时</em>发生的<em>绑定</em>，它<em>指向</em>什么完全取决于函数在哪里被调用</p>
		<h4>关于this的误解</h4>
		<p>①指向自身</p>
		<script>
			function foo(num){
				console.log("foo:"+num);
				//记录foo被调用的次数
				this.count++
			}
			foo.count=0;
			var i;
			for(i=0; i<10;i++){
				if(i>5){
					foo(i);
				}
			}
			console.log(foo.count);//0
			//声明提升后的引擎理解
			/*
				var foo,i;
				foo=function(num){...}
				foo.count=0;//运行到此句时会在函数对象内创建一个count属性
				for(i=0; i<10;i++){
					if(i>5){
						foo(i);//函数被调用，this才被绑定，返回看函数
						function(num){
							var num,this;//函数被调用，this才被绑定
							this=window;//this指向全局
							num=i;
							console.log("foo:"+num);
							//记录foo被调用的次数
							this.count++//由于this指向全局，所以运行到此句时发现全局没有count属性，会创建一个全局变量count，值为NaN;
						}
					}
				}
				console.log(foo.count);//输出0，因为this指向全局，而不是foo;
			*/
		</script>
		<p>②指向函数的作用域</p>
		<p>无法实现this和词法作用域的查找混合使用</p>
		<script>
			function foo(){
				var a=2;
				this.bar();
			}
			function bar(){
				console.log(this.a);//bar()无法访问foo()作用域里的变量
			}
			foo();
			//声明提升后的引擎理解
			/*
				var foo,bar;
				foo=function(){...};
				bar=function(){...};
				foo();//函数被调用，this才被绑定，调用位置是全局作用域，返回看函数
				function(){
					var a,this;
					a=2;
					this=window;//this指向全局对象
					this.bar();//函数被调用，this才被绑定，调用位置是全局作用域，返回看函数
					function(){
						var a,this;//全局并没有声明a
						this=window//this指向全局global
						console.log(this.a);//a is not defined
					}
				}
			*/
		</script>
	</section>
	<hr>
	<section>
		<h3>2.为什么要用this</h3>
		<p>显示传递上下文对象会让代码变得越来越混乱，this提供了一种<em>隐式"传递"</em>一个对象的引用，使用this可以使函数被调用时<em>自动引用合适的上下文对象</em></p>
		<script>
			function identify(){
				return this.name.toUpperCase();
			}
			function speak(){
				var greeting = "Hello,I'm "+identify.call(this);
				console.log(greeting);
			}
			var me={
				name: "Kyle"
			};
			var you={
				name:"Reader"
			};
			identify.call(me);//return KYLE
			identify.call(you);//return READER
			speak.call(me);//Hello,I'm KYLE
			speak.call(you);//Hello,I'm READER

			//声明提升后的引擎理解
			/*
				var identify,speak,me,you;
				identify=function(){...};
				speak=function(){...};
				me={
					name: "Kyle"
				};
				you={
					name:"Reader"
				};
				identify.call(me);//等价于调用函数identify()，此时调用位置是全局作用域，并把this显式绑定到me上，回看函数
				function (){
					var this;
					this=me;//this指向me
					return this.name.toUpperCase();//return KYLE
				}
				identify.call(you);//等价于调用函数identify()此时调用位置是全局作用域，，并把this显式绑定到you上，回看函数
				function (){
					var this;
					this=me;//this指向you
					return this.name.toUpperCase();//return READER
				}
				speak.call(me);//等价于调用函数identify()此时调用位置是全局作用域，，并把this显式绑定到me上，回看函数
				function(){
					var greeting，this;
					this=me;//this指向me
					greeting = "Hello,I'm "+identify.call(this);//等价于调用函数identify()此时调用位置是speak，并把this显式绑定到this（即me）上，回看函数
					console.log(greeting);//Hello,I'm KYLE
				}
				speak.call(you);//等价于调用函数identify()此时调用位置是全局作用域，，并把this显式绑定到you上，回看函数
				function(){
					var greeting，this;
					this=you;//this指向you
					greeting = "Hello,I'm "+identify.call(this);//等价于调用函数identify()此时调用位置是speak，并把this显式绑定到this（即you）上，回看函数
					console.log(greeting);//Hello,I'm READER
				}
			*/
		</script>
	</section>
		<section>
		<h3>3.this怎么用</h3>
		<p>this在<em>调用位置</em>以<em>什么方式（优先级）</em>被绑定，<em>指向谁</em></p>
		<h4>1）调用位置（从调用栈中分析调用位置）</h4>
		<p>方法①：把调用栈想象成函数调用链（麻烦易出错）</p>
		<p>方法②：使用<em>浏览器调试工具</em>:在A函数的第一行代码设置断点（或者插入debugger;语句），打开控制台的调试器的调用堆栈，栈中第二个元素（A函数下一个）就是真正的调用位置</p>
		<script>	
			function baz(){
				//当前调用栈式baz，因此，当前调用位置是全局作用域
				console.log("baz");
				bar();//<--bar的调用位置
			}
			function bar(){
				//当前调用栈式baz-->bar，因此，当前调用位置在baz中
				console.log("bar");
				foo();//<--foo的调用位置
			}
			function foo(){
				//当前调用栈式baz-->bar-->foo，因此，当前调用位置在bar中
				console.log("foo");
			}
			baz();//<--baz的调用位置
		</script>
		<h4>2)确认绑定规则</h4>
		<p>①默认绑定</p>
		<p>若<em>被调用函数使用了"use strict";</em>则当函数被调用时this默认绑定到undefined，否则默认绑定到全局对象</p>
		<script>
			function foo(){
				console.log(this.a);
			}
			var a=2;
			foo();//2

			// function foo(){
			// 	"use strict";
			// 	console.log(this.a);
			// }
			// var a=2;
			// foo();//this is undefined
		</script>
		<p>②隐式绑定</p>
		<p>当上下文对象引用函数时（函数被上下文对象拥有），在函数调用时把this绑定到这个上下文对象</p>
		<script>
			function foo(){
				console.log(this===obj2);//true
				console.log(this.a);
			}
			var obj2={
				a:42,
				foo:foo
			};
			var obj1={
				a:2,
				obj2:obj2
			};
			obj1.obj2.foo();//42
		</script>
		<p>隐式丢失</p>
		<p>方式1：被隐式绑定的函数会丢失this绑定</p>
		<script>
			function foo(){
				console.log(this===window);
				console.log(this.a);
			}
			var obj={
				a:2,
				foo:foo
			};
			var bar=obj.foo;//函数别名
			var a="opps,global"//a是全局对象的属性
			bar();//"opps,global" 函数调用时丢失了的上下文对象(等价于调用了foo();而不是obj.foo();)，this指向全局对象
		</script>
		<p>方式2：回调函数会丢失this绑定</p>
		<script>
			function foo(){
				console.log(this===window);
				console.log(this.a);
			}
			function doFoo(fn){//fn其实引用的是foo
					fn();//<--调用位置,函数调用时丢失了的上下文对象(等价于调用了foo();而不是obj.foo();)，this指向全局对象
			}
			var obj={
				a:2,
				foo:foo
			};
			var a="opps,global"//a是全局对象的属性
			doFoo(obj.foo);//"opps,global"
		</script>
		<p>③显式绑定</p>
		<p>通过call()和apply()方法直接指定this的绑定对象</p>
		<script>
			function foo(){
				console.log(this===obj);
				console.log(this.a);
			}
			var obj={
				a:2,
			};
			foo.call(obj);//等价于调用函数foo()此时调用位置是全局作用域，并把this显式绑定到obj上
		</script>
		<p>硬绑定--显式绑定的变种，解决绑定丢失问题</p>
		<script>
			function foo(){
				console.log(this===obj);
				console.log(this.a);
			}
			var obj={
				a:2,
			};
			var bar=function(){
				console.log(this===window);
				foo.call(obj);
			};
			 bar();//2
			 // setTimeout(bar,1000);//2
			//硬绑定的bar不可能再修改它的this
			bar.call(window);//2
		</script>
		<p>硬绑定的应用场景一：创建一个包裹函数，传入所有的参数并返回接收到的所有值</p>
		<script>
			function foo(something){
				console.log(this.a,something);
				return this.a+something;
			}
			var boj={
				a:2
			};
			var bar=function(){
				return foo.apply(obj,arguments);
				// return foo.call(obj,arguments);
			};
			var b=bar(3,1,2,3);//2 3
			console.log(b);//5
		</script>
		<p>Funtion.prototype.bind()--ES5内置的方法实现硬绑定</p>
		<script>
			function foo(something){
				console.log(this.a,something);
				return this.a+something;
			}
			var boj={
				a:2
			};
			// var bar=foo.bind();
			var bar=foo.bind(obj);//bind()返回一个硬编码的新函数，把参数设置为this的上下文并调用原始函数
			var b=bar(3,1,2,3);//2 3
			console.log(b);//5
		</script>
		<p>④new绑定</p>
		<p>JavaScript中的<a href="#constructor">构造函数</a>只是一些<em>使用new操作符时</em>被调用的<em>普通函数</em>，并不会属于某个类，也不会实例化一个类</p>
		<p>使用new调用函数，会执行以下操作</p>
		<p>1.创建一个全新的对象</p>
		<p>2.新对象被执行[[原型]]连接</p>
		<p>3.新对象会绑定到函数调用的this</p>
		<p>4.如果函数没有其他返回对象，那么new表达式中的函数调用会自动返回这个新对象</p>
		<script>
			function foo(a){
				this.a=a;
			}
			var bar=new foo(2);
			console.log(bar.a);//2
		</script>
		<h4>3）优先级</h4>
		<p>判断this</p>
		<p>1.函数是否在new中调用（new绑定）？如果是的话this绑定的是新创建的对象。</p>
		<p>var bar = new foo()</p>
		<p>2. 函数是否通过call、apply（显式绑定）或者硬绑定调用？如果是的话，this绑定的是指定的对象。</p>
		<p>var bar = foo.call(obj2)</p>
		<p>3.函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this绑定的是那个上下文对象。</p>
		<p>var bar = obj1.foo()</p>
		<p>4.如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到全局对象。</p>
		<p>var bar=foo()</p>
		<h4>4）绑定的例外（详见《你不知道的JavaScript上卷》）</h4>
		<p>被忽略的this</p>
		<p>间接引用</p>
		<p>软绑定</p>
		<p></p>
		<h4>5）this词法（详见《你不知道的JavaScript上卷》）</h4>
	</section>
	<hr>
	<section>
	<h3>相关知识</h3>
		<pre name="constructor" id="constructor">
		构造函数:
		当任意一个普通函数用于创建一类对象时，它就被称作构造函数，或构造器。例如：new String(“a string”)，调用内置的String函数构造了一个字符串对象
		
		执行var o2 = new CO();创建对象的时候，发生了四件事情：
		var obj  ={};
		obj.__proto__ = CO.prototype;
		CO.call(obj);//this指向obj，而不是o2
		return obj;

		自定义的函数将来可以将他的实例标识为一种特定的类型，因为它只道自己从哪里来，通过谁产生的，这样可以减少内存资源的浪费

		有内置的函数，直接new内置函数没有先创建普通函数（通常函数首字母大写），再用new创建函数对象
												<a href="constructor.html" target="_blank">--更多</a>
		</pre>
	</section>
</body>
</html>