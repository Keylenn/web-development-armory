<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>JSON对象（在JavaScript使用JSON）</title>
	<style>
		em{
			color:red;
			font-size: 18px;
		}
	</style>
</head>
<body>
	<section>
	<h3>什么是JSON</h3>
	<h4>1.概念</h4>
	<p>json(javascript object notation)全称是javascript对象表示法，它是一种<em>轻量级的数据格式</em>，而不是一种编程语言，用于读取结构化数据</p>
	<h4>2.语法规则</h4>
	<p>1）简单值</p>
	<p>　简单值使用与JavaScript相同的语法，可以在JSON中表示字符串、数值、布尔值和null
字符串<em>必须使用双引号表示</em>，不能使用单引号。数值必须以<em>十进制</em>表示，且<em>不能使用NaN和Infinity，[注意]JSON不支持JavaScript中的特殊值undefined</em></p>
	<pre>
//合格的简单值
"hello world"
true
null
//不合格的简单值
+0x1
'hello world'
undefined
NaN
Infinity
	</pre>
	<p>2）对象</p>
	<p>对象作为一种复杂数据类型，表示的是一组<em>有序的键值对</em>。而每个键值对儿中的值可以是简单值，也可以是复杂数据类型的值</p>
	<p>与javascript的对象字面量相比，json有三个不同的地方</p>
	<p>1>JSON没有变量的概念</p>
	<p>2>JSON中，对象的<em>键名</em>必须放在<em>双引号</em>里面</p>
	<p>3>因为JSON不是javascript语句，所以<em>没有末尾的分号</em></p>
	<p><em>[注意]同一个对象中不应该出现两个同名属性</em></p>
　　<pre>
//合格的对象
{
    "name":"huochai",
    "age":29,
    "school":{
        "name":"diankeyuan",
        "location":"beijing"
    }
}
//不合格的对象
{ name: "张三", 'age': 32 }//属性名必须使用双引号
{};//不需要末尾的分号
{ "birthday": new Date('Fri, 26 Aug 2011 07:13:10 GMT'),
  "getName": function() {
      return this.name;
  }
} // 不能使用函数和日期对象
	</pre>
	<p>3)数组</p>
	<p>数组也是一种复杂数据类型，表示一组有序的值的列表，可以通过<em>数值索引来访问其中的值</em>。数组的值也可以是任意类型——简单值、对象或数组</p>
	<p>JSON数组也没有变量和分号，把数组和对象结合起来，可以构成更复杂的数据集合</p>
	<p>[注意]数组或对象最后一个成员的后面，<em>不能加逗号</em></p>
	
	</section>
	<hr>

　　<section>
		<h3>为什么要用JSON</h3>
		<p>JSON数据结构取代繁琐的XML格式，可以把JSON数据结构解析为有用的javascript对象</p>
		<p>ECMAScript5对解析JSON的行为进行了规范，定义了<em>全局对象JSON，[注意]IE7-浏览器不支持</em></p>
		<p>JSON对象有两个方法：<em>stringify()和parse()：</em>这两个方法分别用于把JavaScript对象<em>序列化</em>为JSON字符串和把JSON字符串<em>解析（反序列化）</em>为原生JavaScript值</p>
		<p>1）JSON.stringify(value [, filter] [, indent]) </p>
		<p>参数：①要序列化的JavaScript<em>对象（必须）</em>②<em>过滤器</em>，可以是一个数组，也可以是一个函数；③<em>缩进</em>，表示是否在JSON字符串中保留缩进（参数②③可选，用于指定以<em>不同的方式</em>序列化JavaScript对象，默认情况下，JSON.stringify()输出的JSON字符串不包括任何空格字符或缩进）</p>
		<p>第一个参数--JavaScript对象（数组，类等）在序列化过程中：</p>
		<pre>
	把正则表达式和数学对象转换成空对象的字符串形式
	把日期对象和包装对象转换成字符串
	如果对象的成员是undefined或函数，这个成员会被省略
	如果数组的成员是undefined或函数，则这些值被转成null
	会忽略对象的不可遍历的属性
		</pre>
		<script>
			var jsonObj={
				tittle:"javascript",
				group:{
					name:"jia",
					tel:12345
				}
			};
			console.log(JSON.stringify(jsonObj));//{"tittle":"javascript","group":{"name":"jia","tel":12345}}

			//stringify()方法把正则表达式和数学对象转换成空对象的字符串形式
			console.log(JSON.stringify(/foo/));//{}
			console.log(JSON.stringify(Math));//{}

			//stringify()方法把日期对象和包装对象转换成字符串
			console.log(JSON.stringify(new Boolean(true)));//true
			console.log(JSON.stringify(new String('123')));//"123"
			console.log(JSON.stringify(new Number(1)));//1
			console.log(JSON.stringify(new Date()));//"2017-11-03T05:17:35.721Z"

			//如果对象的成员是undefined或函数，这个成员会被省略
			//如果数组的成员是undefined或函数，则这些值被转成null
			var jsonObj2={
				a:function(){},
				b:undefined,
				c:[function(){},undefined]
			};
			console.log(JSON.stringify(jsonObj2));//{"c":[null,null]}

			//　JSON.stringify()方法会忽略对象的不可遍历的属性
			var obj = {};
			Object.defineProperties(obj, {
			  	'foo': {
			    	value: 1,
			    	enumerable: true
			  	},
			  	'bar': {
			    	value: 2,
			    	enumerable: false
			  	}
			});
			console.log(JSON.stringify(obj)); // {"foo":1}
		</script>

		<p>第二个参数--过滤器(数组或函数)在序列化过程中：</p>
		<pre>
		过滤器为函数时（该函数接收两个参数，一个键和一个值，返回一个值），把系列化后的每一个对象（记住是每一个）传进方法里面进行处理
		过滤器为数组时，看参数2的值在参数1中是否找得到，没有则忽略参数2，有就将该值作为参数1的key
		</pre>
		<script>
			var students = new Array() ; 
			students[0] = "onepiece"; 
			students[1] = "naruto"; 
			students[2] = "bleach"; 
			function switchUpper(key, value) { 
			    return value.toString().toUpperCase(); 
			} 
			console.log(JSON.stringify(students,switchUpper));//"ONEPIECE,NARUTO,BLEACH"

			var stuArr1 = new Array() ; 
			stuArr1[0] = "onepiece"; 
			stuArr1[1] = "naruto"; 
			stuArr1[2] = "bleach"; 
			var stuArr2 = new Array(); //参数2的值在参数1中找不到，忽略参数2，直接序列化参数1
			stuArr2[0] = "stuArr1"; 
			stuArr2[0] = "stuArr1[0]"; 
			stuArr2[1] = "2"; 
			console.log(JSON.stringify(stuArr1,stuArr2));//["onepiece","naruto","bleach"]

			var stuObj = new Object(); 
			stuObj.id = "20122014001"; 
			stuObj.name = "Tomy"; 
			stuObj.age = 25; 
			var stuArr = new Array(); 
			stuArr[0] = "id"; 
			stuArr[1] = "age"; 
			stuArr[2] = "addr";//这个stuObj对象里不存在。 
			console.log(JSON.stringify(stuObj,stuArr));//{"id":"20122014001","age":25}
		</script>
		<p>第三个参数--缩进(数字,'\t',字符串)在序列化过程中：</p>
		<pre>
		如果省略的话，那么显示出来的值就没有分隔符，直接输出来 。
　　		如果是一个数字的话，那么它就定义缩进几个字符，当然如果大于10 ，则默认为10，因为最大值为10。
　　		如果是一些转义字符，比如“\t”，表示回车，那么它每行一个回车。
 		如果仅仅是字符串，就在每行输出值的时候把这些字符串附加上去。当然，最大长度也是10个字符。 
		</pre>
		<script>
			var stuObj = new Object(); 
			stuObj.id = "20122014001"; 
			stuObj.name = "Tomy"; 
			stuObj.age = 25; 
			var stuArr = new Array(); 
			stuArr[0] = "id"; 
			stuArr[1] = "age"; 
			stuArr[2] = "addr";//这个stuObj对象里不存在。 
			console.log(JSON.stringify(stuObj,stuArr));//{"id":"20122014001","age":25}
			console.log(JSON.stringify(stuObj,stuArr,5));
			console.log(JSON.stringify(stuObj,stuArr,100));
			console.log(JSON.stringify(stuObj,stuArr,'\t'));
			console.log(JSON.stringify(stuObj,stuArr,'@---'));
		</script>
		<p>2)toJSON方法--函数过滤器的补充</p>
		<p>有时候，JSON.stringify()还是不能满足对某些对象进行自定义序列化的需求。在这些情况下
象上调用toJSON()方法，返回其自身的JSON数据格式</p>
		<pre>
	如果toJSON()方法返回undefined，如果包含它的对象是顶级对象结果就是undefined，此时如果包含它的对象嵌入在另一个对象中，会导致该对象的值变成null。
	Date对象部署了一个自己的toJSON方法，自动将Date对象转换成日期字符串
	toJSON方法可以将正则对象自动转为字符串
		</pre>
		<script>
			var o1 = {
  				foo: 'foo',
  				toJSON: function() {
    				return 'bar';
  				}
			};
			console.log(JSON.stringify({x:o1}));//{"x":"bar"},直接调用toJSON()方法
			var o2 = {
  				foo: 'foo',
  				toJSON: function() {
    				return undefined;
  				}
			};
			console.log(JSON.stringify(o2));//undefined,包含toJSON()的对象是顶级对象o2
			console.log(JSON.stringify({x:o2}));//{},包含toJSON()的对象o2嵌入在另一个对象x中

			RegExp.prototype.toJSON =RegExp.prototype.toString;
			console.log(JSON.stringify(/foo/));// /foo/"

		</script>
		<p>3)JSON.parse(text[, reviver])</p>
		<p>参数：①text:必需， 一个 <em>有效的JSON 字符串</em>②reviver: 可选，一个转换结果的函数， 将为对象的<em>每个成员</em>调用此函数</p>
		<p>第一个参数--一个有效的JSON 字符串,不是有效的JSON格式将报错</p>
		<script>
			console.log(JSON.parse('{}')); // Object {  }
			console.log(JSON.parse('true'));// true
			console.log(JSON.parse('"foo"') );// foo
			console.log(JSON.parse('[1, 5, "false"]'));// Array [ 1, 5, "false" ]
			console.log(JSON.parse('null'));// null
			var o = JSON.parse('{"name": "张三"}');
			console.log(o);//Object { name: "张三" }
			console.log(o.name);// 张三
		</script>
		<p>第二个参数--还原函数（该函数接收两个参数，一个键和一个值，返回一个值）</p>
		<pre>
	在将日期字符串转换为Date对象时，经常要用到还原函数
		</pre>
		<script>

			var o = JSON.parse('{"a":1,"b":2}', function(key, value) {
			  if (key === ''){
			    return value;
			  }
			  if (key === 'a') {
			    return value + 10;
			  }
			});
			console.log(JSON.parse('{"a":1,"b":2}'));//Object { a: 1, b: 2 }没有第二个参数时
			//有第二参数时
			console.log(o);//Object { a: 11 }
			console.log(o.a);// 11
			console.log(o.b);// undefined

			var book = {
			    "title": "javascript",
			    "date": new Date(2016,9,1)
			}
			var jsonStr = JSON.stringify(book);
			console.log(jsonStr)//{"title":"javascript","date":"2016-09-30T16:00:00.000Z"}

			var bookCopy = JSON.parse(jsonStr,function(key,value){
			    if(key == 'date'){
			        return new Date(value);
			    }
			    return value;
			})
			console.log(bookCopy);//Object { title: "javascript", date: Date 2016-09-30T16:00:00.000Z }
			console.log(bookCopy.date.getFullYear());//2016
		</script>
		<p>4)eval()类似于JSON.parse()方法，可以将json字符串转换为json对象,但是由于以执行不符合JSON格式的代码，有可能会包含恶意代码，不推荐使用</p>
		<script>	
			console.log(eval('(' + '{"a":1}'+')').a);//1
			console.log(JSON.parse('{"a":1}').a);//1

			eval('(' + '{"a":console.log(1)}'+')').a;//1
			// JSON.parse('{"a":console.log(1)}').a;//报错
		</script>
	</section>
	<hr>

　　<section>
		<h3>JSON怎么用</h3>
		<h4>JSON.stringify()把JavaScript对象序列化为JSON字符串</h4>
		<p>序列化的内部顺序：</p>
		<pre>
	1、如果存在toJSON()方法而且能通过它取得有效的值，则调用该方法。否则，按默认顺序执行序列化
	2、如果提供了第二个参数，应用这个函数过滤器。传入函数过滤器的值是第一步返回的值
	3、对第二步返回的每个值进行相应的序列化
	4、如果提供了第三个参数，执行相应的格式化		
		</pre>
		<script>
			var o1 = {
  				foo: 'foo',
  				toJSON: function() {
    				return 'bar';
  				}
			};
			var func=function(key,value){
				return"I am "+value;
			};
			console.log(JSON.stringify(o1,func,'\t'));//"I am bar"
		</script>
		<h4>JOSN.parse()把JSON字符串解析（反序列化）为原生JavaScript值</h4>
			<script>
				var book = {
			    "title": "javascript",
			    "date": new Date()
			}
			var jsonStr = JSON.stringify(book);
			console.log(jsonStr);//{"title":"javascript","date":"2017-11-03T08:39:30.644Z"}
			var bookCopy = JSON.parse(jsonStr,function(key,value){
			    if(key == 'date'){
			        return new Date(value);
			    }
			    return value;
			})
			console.log(bookCopy.date.getFullYear());//2017
			</script>
	
			
	</section>
　　
</body>
</html>