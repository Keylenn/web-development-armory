<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>事件机制</title>
	<style>
		em{
			color:red;
			font-size:18px;
		}
	</style>
</head>
<body>
	<article>
		<h4>一、事件流：指从页面中接收事件的顺序，有冒泡流和捕获流</h4>
		<p>obj.addEventListener("click", func, true);  捕获方式</p>
		<p>obj.addEventListener("click", func, false);  冒泡方式</p>
	
		<p>为了兼容更多的浏览器，非特殊情况一般我们都是把事件添加到在事件冒泡阶段。</p>
		<hr>
	</article>
	<article>
		<h4>二、事件处理程序</h4>
		<p>DOM0级事件处理程序</p>
		<button id="btn1">DOM0级事件处理</button>
		<script>
			var btn1 = document.getElementById('btn1');
			btn1.onclick=function(){
				console.log(this.id);//btn1   
				btn1.onclick=null;
			};
				

		</script>

		<p>DOM2级事件处理程序</p>
		<button id="btn2">DOM2级事件处理</button>
		<script>
			var btn2 = document.getElementById('btn2');
			var handlers = function () {
			   console.log(this.id);
			   btn2.removeEventListener('click',handlers,false);
			};
			btn2.addEventListener('click',handlers,false);//IE8-不支持
							
		</script>
		<!-- <p>IE事件处理程序（在IE10以下或opera上运行）</p>
		<button id="btn3">IE事件处理</button>
		<script>
			var btn3 = document.getElementById('btn3');
			var handlers2=function(e){
				e.cancelBubble();
				console.log(this===window);//true,注意attachEvent()添加的事件处理程序运行在全局作用域中;
				btn3.detachEvent('onclick',handlers2);
			};
			btn3.attachEvent('onclick',handlers2);
		</script> -->
		<p>跨浏览器事件处理程序</p>
		<button id="btn4">跨浏览器事件处理</button>
		<script>
			//创建的方法是addHandlers(),removeHandlers(),这两个方法属于一个叫EventUtil的对象;但是这个没有考虑到IE中作用域的问题，不过就添加和移除事件还是足够的。
			var EventUtil = {
			   addHandlers: function (element, type, handlers) {
			      if (element.addEventListener) {
			         element.addEventListener(type, handlers, false);
			      } else if (element.attachEvent) {
			         element.attachEvent(on + type, handlers);//ie8显示on未定义
			      } else {
			         element['on' + type] = handlers;
			      }
			   },
			   removeHandlers: function (element, type, handlers) {
			      if (element.removeEventListener) {
			         element.removeEventListener(type, handlers, false);
			      } else if (element.detachEvent) {
			         element.detachEvent(on + type, handlers);
			      } else {
			         element['on' + type] = null;
			      }
			   }
			};
			var btn4=document.getElementById("btn4");
			var handlers3=function(){
				console.log(this===window);
				console.log(this);
				EventUtil.removeHandlers(btn4,'click',handlers3); 
			};
			EventUtil.addHandlers(btn4,'click',handlers3); 

		</script>
		<hr>
	</article>
	<article>
		<h4>三、事件对象</h4>
		<p>DOM中的事件对象</p>
		<p>关于事件对象中的this，target，currentTarget,看个例子：（注：event.target不支持IE浏览器，应该用event.srcElement；还有 IE中通过attachment添加的事件是运行在全局作用域中的，this===window），当事件绑定在真正的目标元素上时，this===target===currentTarget ,而且绑定事件时是否捕获结果都是一样的，此时eventParse==2;</p>
		<button id="btn5">DOM中的事件对象</button>
		<p><em>event.stopPropagation()</em>不能简单说阻止了事件的冒泡，其实也阻止了事件的继续捕获，确切的说应该是<em>阻止事件的进一步传播，</em>但它阻止不了绑定在该元素上的<em>其他函数的执行</em></p>
		<p><em>stopImmediatePropagation()</em>不仅<em>阻止事件的传播</em>还阻止<em>后续事件的执行</em></p>
		<div id="div1">
			<span>div1--span</span>
			<div id="div2">
				<br>
				<span>div2--span</span>
			</div>
		</div>
				
		<script>
		var btn5=document.getElementById('btn5');
		// btn5.onclick=function(e){
		// 	console.log(this.id);
		// 	console.log(e.target.id);
		// 	console.log(e.currentTarget.id);
		// };//DOM0级事件处理程序
		var handlers4=function(e){
			console.log(this.id);
			console.log(e.target.id);
			console.log(e.currentTarget.id);
			btn5.removeEventListener('click',handlers4,false);
		};//DOM2级事件处理程序
		btn5.addEventListener('click',handlers4,false);
		
		var div1=document.getElementById("div1");
		var handlers5=function(evt){
			console.log('div1');
			//evt.stopPropagation(); ①event.stopPropagation()可以阻止事件的传播，但它阻止不了绑定在该元素上的其他函数的执行,因此当你点击div1或div2时都会显示div1和div11
			//evt.stopImmediatePropagation(); ②stopImmediatePropagation()不仅阻止事件的传播还阻止后续事件的执行,因此当你点击div1时都只会显示div1，点div2没反应
			
		};
		div1.addEventListener('click',handlers5,true);

		var handlers6=function(evt){
			console.log('div1'+1);
		};
		div1.addEventListener('click',handlers6,true);

		var div2=document.getElementById("div2");
		var handlers7=function(evt){
			console.log('div2');
		};
		div2.addEventListener('click',handlers7,true);
		</script>
		
		<p>跨浏览器的事件对象</p>
		<div id="div3">	div3
			<div id="div4">div4</div>
		</div>
		<script>
			var EventUtil2={
				
			   addHandler:function(element,type,handler){ //添加事件
			      if(element.addEventListener){ 
			         element.addEventListener(type,handler,false);  //使用DOM2级方法添加事件
			      }else if(element.attachEvent){                    //使用IE方法添加事件
			         element.attachEvent("on"+type,handler);
			      }else{
			         element["on"+type]=handler;          //使用DOM0级方法添加事件
			      }
			   },  

			   removeHandler:function(element,type,handler){  //取消事件
			      if(element.removeEventListener){
			         element.removeEventListener(type,handler,false);
			      }else if(element.detachEvent){
			         element.detachEvent("on"+type,handler);
			      }else{
			         element["on"+type]=null;
			      }
			   },

			   getEvent:function(event){  //使用这个方法跨浏览器取得event对象
			      return event?event:window.event;
			   },
				
			   getTarget:function(event){  //返回事件的实际目标
			      return event.target||event.srcElement;
			   },
				
			   preventDefault:function(event){   //阻止事件的默认行为
			      if(event.preventDefault){
			         event.preventDefault(); 
			      }else{
			         event.returnValue=false;
			      }
			   },

			   stopPropagation:function(event){  //立即停止事件在DOM中的传播
			                                     //避免触发注册在document.body上面的事件处理程序
			      if(event.stopPropagation){
			         event.stopPropagation();
			      }else{
			         event.cancelBubble=true;
			      }
			   },
					
			   getRelatedTarget:function(event){  //获取mouseover和mouseout相关元素
			      if(event.relatedTarget){
			         return event.relatedTarget;
			      }else if(event.toElement){      //兼容IE8-
			         return event.toElement;
			      }else if(event.formElement){
			         return event.formElement;
			      }else{
			         return null;
			      }
			   },
					
			   getButton:function(event){    //获取mousedown或mouseup按下或释放的按钮是鼠标中的哪一个
			      if(document.implementation.hasFeature("MouseEvents","2.0")){
			         return event.button;
			      }else{
			         switch(event.button){   //将IE模型下的button属性映射为DOM模型下的button属性
			            case 0:
			            case 1:
			            case 3:
			            case 5:
			            case 7:
			               return 0;  //按下的是鼠标主按钮（一般是左键）
			            case 2:
			            case 6:
			               return 2;  //按下的是中间的鼠标按钮
			            case 4:
			               return 1;  //鼠标次按钮（一般是右键）
			         }
			      }
			   },
					
			   getWheelDelta:function(event){ //获取表示鼠标滚轮滚动方向的数值
			      if(event.wheelDelta){
			         return event.wheelDelta;
			      }else{
			         return -event.detail*40;
			      }
			   },
					
			   getCharCode:function(event){   //以跨浏览器取得相同的字符编码，需在keypress事件中使用
			      if(typeof event.charCode=="number"){
			         return event.charCode;
			      }else{
			         return event.keyCode;
			      }
			   }
					
			};
			var div3=document.getElementById("div3");
			var div4=document.getElementById("div4");
			var handlers8=function(e){
				e=EventUtil2.getEvent(e);
				console.log('div3');//div3
				
			};
			EventUtil2.addHandler(div3,'click',handlers8);

			var handlers9=function(e){
				e=EventUtil2.getEvent(e);
				console.log('div4');
				EventUtil2.stopPropagation(e);//因为是冒泡，所以只显示div4
			};
			EventUtil2.addHandler(div4,'click',handlers9);//冒泡：div4 div3 
		</script>	
		<hr>
	</article>
	<article>
		<h4>四、事件委托</h4>
		<p>因为把事件绑定到了父节点上，因此省了绑定事件。就算后面新增的子节点也有了相关事件，删除部分子节点不用去销毁对应节点上绑定的事件</p>
    	<p>父节点是通过event.target来找对应的子节点的。（事件处理程序中的this值始终等于currentTarget的值，指向的是绑定到的那个元素,而不是target）</p>
		<ul id="u">
			<li id="l1">l1</li>
			<li id="l2">l2</li>
			<li id="l3">l3</li>
		</ul>
    	<script>
    		var u=document.getElementById('u');
			myHandlers=function(event){
			    var event=EventUtil2.getEvent(event);
			    var target=EventUtil2.getTarget(event);

			    switch(target.id){
			        case 'l1':
			           console.log(target.id==this);//false，this指向被绑定的父元素ul，target指向第一个li
			            break;
			        case 'l2':
			        	console.log(target.id);//l2
			            console.log(this.id);//u
			            break;
			        default :
			        	console.log("还未添加事件哦")
			    }
			};
			EventUtil2.addHandler(u,'click',myHandlers);
    	</script>
	</article>
</body>
</html>