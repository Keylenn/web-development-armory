<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>原型</title>
	<style>
		em{
			color:red;
			font-size:18px;
		}
		a{
			text-decoration:none;
			color:rgba(0,0,255,0.6);
		}
	</style>
</head>
<body>
	<section>
		<h3>什么是原型（对象）</h3>
		<h4>概念</h4>
		<p>原型是一个对象，自然有一个内置的<em>[[prototype]]属性</em>（不可以被直接访问），这个属性所对应的就是该对象的原型；同时自动获得一个<em>constructor(构造函数)</em>属性，这个属性包含一个指针，指向创建所有指向该原型的实例的构造函数</p>
		<h4>原型链</h4>
		<p>原型链：当从一个对象那里调取属性或方法时，如果该对象自身不存在这样的属性或方法，就会去自己<em>关联的prototype对象（内部初始化的[[prototype]]属性）</em>那里寻找，如果prototype没有，就会去prototype关联的前辈prototype那里寻找，如果再没有则继续查找Prototype.Prototype引用的对象，依次类推，直到Prototype.….Prototype为undefined（Object的Prototype就是undefined）从而形成了所谓的“原型链”。</p>
		<script>
			function Person(){}
			Person.prototype.name="NIcholas";
			Person.prototype.age="29";
			Person.prototype.job="Software Engineer";
			Person.prototype.sayName=function(){
				console.log(this.name);
			};
			var person1=new Person;
			var person2=new Person;
			console.log(person1.__proto__===Person.prototype);//true
		</script>
		<img src="imgs/Prototype.jpg" alt="">
		<img src="imgs/PrototypeChain.jpg" alt="">
		<h4>易错解析</h4>
		<p>1）区别对象、原型、函数、构造函数</p>
<pre>
	①对象，有一个内置的[prototype]]属性，这个属性所对应的就是该对象的原型，但是这个属性不能
	 被直接访问的。所以为了方便查看一个对象的原型，Firefox和Chrome中提供了<em>__proto__</em>
	 这个非标准（不是所有浏览器都支持）的访问器,（ECMA引入了标准对象原型访问器”Object.getPrototypeOf(obj)”）
	②原型,是一个对象，因此拥有内置的[prototype]]属性，同时自动获得一个constructor属性，
	 这个属性包含一个指针，指向创建所有指向该原型的实例的构造函数
	③函数，作为对象，有一个内置的[prototype]]属性，这个属性所对应的就是该对象的原型Function；
	 作为函数，会根据一组特定的规则为该函数创建一个特殊的prototype内置属性，指向函数对象的原型对象
	④构造函数（命名时首字母一般大写），执行var p = new Person('张三',20);创建对象的时候，发生了四件事情：
	  var obj={}; 初始化一个对象obj。
	  obj._proto_=Person.prototype;，将对象obj的 __proto__ 属性设置为 Person.prototype
	  Person.call(obj,”张三”,20);调用构造函数Person来初始化obj
	  return obj;//将obj的引用传递给p
</pre>
		<p>__proto__属性是一些浏览器为了可以访问到<em>对象</em>的原型而设置的，是来代替对象内置的[prototype]]属性，而在<em>函数</em>被创建时，会根据一组特定的规则为该函数创建一个特殊的prototype内置属性，该函数的prototype属性值将被作为原型赋值给所有对象实例（也就是设置实例的__proto__属性）</p>
		<p>Object对象本身是一个函数对象,有prototype属性，所以可以看到”Object.prototype”的值就是”Object {}”这个原型对象,当访问”Object.prototype”对象的”constructor”这个属性的时候，就得到了Obejct函数</p>

		<p>2）原型链（家庭关系图）：有构造函数（中介）参与的儿子（实例）找<em>爸爸（原型,用中介.prototype来表示）</em>的过程，儿子通过__proto__属性委托中介（儿子._proto__=中介.prototype）通过prototype属性帮找爸爸，爸爸可以通过constructor属性定位中介（间接找儿子），儿子也可以通过在爸爸那里得到constructor属性从而间接定位中介，因此，在寻找过程必须时刻明确角色和行为，<em>注意！</em>这些关系成立的前提是对象的原型没有被重写</p>
		<script>

			//Object对象作为儿子找爸爸,找到构造函数function Function()，把Object.__proto__=Function.prototype,通过Function.prototype找到Object的爸爸是function ()
			console.log(Object.__proto__);//function ()
			console.log(Object.__proto__===Function.prototype);//true
			//Object对象的爸爸作为儿子找爸爸,找到构造函数 function Object()把Function.prototype.__proto__=Object.prototype,通过Object.prototype找到Object对象的爸爸的爸爸是Object { , 等 15 项… }
			console.log(Function.prototype.__proto__);//Object { , 等 15 项… }
			console.log(Function.prototype.__proto__===Object.prototype);//true


			//Object的爸爸作为爸爸，通过constructor属性定位中介是function Function()
			console.log(Function.prototype.constructor);//function Function()
			//Object作为儿子是没有constructor属性的，不能直接定位中介，只能通过在爸爸（Function.prototype）那里得到constructor属性，所以返回的同样是function Function()
			console.log(Object.constructor);

			//由于Object对象本身是一个函数对象，存在function Object()，因此当new后Object对象作为构造函数function Object()
			var obj=new Object();//等价于var obj={};

			// obj作为儿子找爸爸，找到构造函数 function Object()把obj.__proto=Object.prototype,通过Object.prototype找到obj的爸爸是Object { , 等 15 项… }
			console.log(obj.__proto__);//Object { , 等 15 项… }				
			console.log(Object.getPrototypeOf(obj));//Object { , 等 15 项… }		
			console.log(obj.__proto__===Object.prototype);//true
			//obj的爸爸作为儿子找爸爸，找不到中介委托，返回一个空对象null
 			console.log(Object.prototype.__proto__);//null

			//obj的爸爸作为爸爸，通过constructor属性定位中介是function Object()
			console.log(Object.prototype.constructor);//function Object()


			//并不存在function obj()，所以当var objson=new obj();时会报错obj is not a constructor，obj不能作为构造函数,所以当你访问obj.prototype会警告你正在访问一个不存在的对象属性，并返回undefined
			//console.log(obj.prototype);//undefined


			function Co(){
				var name="abcd";
				name="ac";
			}//等价于 var Co= new Function("namename='abcd'; name='ac';");
			var obj2=new Co();

			//Co作为儿子找爸爸，找到构造函数function Function()，把Co.__proto__=Function.prototype,通过Function.protype找到Co的爸爸是function ()
			console.log(Co.__proto__);//function ()
			console.log(Co.__proto__===Function.prototype)//true
			//Co的爸爸作为儿子找爸爸，找到构造函数 function Object()把Function.prototype.__proto__=Object.prototype,通过Object.prototype找到Co的爸爸的爸爸是Object { , 等 15 项… }
			console.log(Function.prototype.__proto__);//Object { , 等 15 项… }
			console.log(Function.prototype.__proto__===Object.prototype);//true

			//Co的爸爸作为爸爸，通过constructor属性定位中介是function Function()
			console.log(Function.prototype.constructor);//function Function()



			//obj2作为儿子找爸爸，找到构造函数function	Co(),把obj2.__proto__=Co.prototype，通过Co.protype找到obj2的爸爸是
			console.log(obj2.__proto__);//Object { , 等 1 项… }
			console.log(obj2.__proto__===Co.prototype);//true
			//obj2的爸爸作为儿子找爸爸，找到构造函数 function Object(),把Co.prototype.__proto__=Object.prototype，通过Object.prototype找到obj2的爸爸的爸爸是Object { , 等 15 项… }
			console.log(Co.prototype.__proto__);//Object { , 等 15 项… }
			console.log(Co.prototype.__proto__===Object.prototype);//true

			//obj2的爸爸作为爸爸，通过constructor属性定位中介是function Co()
			console.log(Co.prototype.constructor);//function Co()
			//obj2作为儿子定位中介，由于本身没有constructor属性，只能通过在爸爸（Co.prototype）那里得到constructor属性，所以同样地返回function Co()
			console.log(obj2.constructor);//function Co()
		</script>
		<p>3）是否应该拓展内建对象？</p>
		<p>学习了原型，我们可以知道内建对象(更准确是内建的构造函数)的来龙去脉，也就可以在适当的时候对它进行扩展<a href="#exBnObj" name="b1" id="b1">（具体实现）</a>，而且应该养成这样的习惯，想通过原型为某个对象添加属性和方法时，先检查其是否存在</p>
		<pre>
			if(!String.prototype.reverse){...}
		</pre>
		<p>4)一些原型陷阱</p>
		<p>①当我们对原型对象执行完全替换时，可能会触发原型链的某种异常（exception）</p>
		<p>②prototype.constructor属性是不可靠的,因此当我们<em>重写</em>某对象的原型对象（Prototypr）时，<em>重置</em>相应的constructor属性</p>
		<script>
			function Dog(){}
				Dog.prototype.tail=true;
				Dog.prototype.say = function(){return 'Woof!'}
				console.log(Dog.prototype);//Object { tail: true, say: Dog.prototype.say(), 等 1 项… }

				var benji = new Dog();
				//benji作为儿子定位中介，由于本身没有constructor属性，只能通过在爸爸（Dog.prototype）那里得到constructor属性，所以返回function Dog()
				console.log(benji.constructor)//function Dog()

				Dog.prototype={paws:4,hair:true};//重写Dog.prototype
				console.log(Dog.prototype);//Object { paws: 4, hair: true }

				//benji并没有这个属性，作为儿子找爸爸，通过__proto__属性委托中介Dog()的prototype属性，找到爸爸Dog.prototype,由于benji在重写Dog.prototype前就被实例化，所以里面只有有tail属性和say方法
				console.log(benji.tail);//true
				console.log(benji.say());//Woof!
				console.log(benji.paws);//undefined

				var rusty = new Dog();
				//rusty并没有这个属性，作为儿子找爸爸，通过__proto__属性委托中介Dog()的prototype属性，找到爸爸Dog.prototype,由于rusty在重写Dog.prototype后才被实例化，所以里面只有有paws属性和hair属性
				console.log(rusty.tail);//undefined
				console.log(rusty.hair);//true

				//rusty作为儿子定位中介，由于本身没有constructor属性，只能通过在爸爸（Dog.prototype）那里得到constructor属性，但是由于Dog.prototype被重写，没有了constructor属性，只能通过rusty爸爸的爸爸（Dog.prototype.__proto__）那里得到constructor属性，所以返回function Object()
				console.log(Dog.prototype.__proto__);//Object { , 等 15 项… }
				console.log(rusty.constructor);//function Object()

				//为解决重写原型对象后的constructor属性能保持正确的指向，重写时应该重置相应的constructor属性
				Dog.prototype={
				paws:10,
				hair:false,
				say : function(){return 'dog!'}
				};//重写Dog.prototype
				Dog.prototype.constructor = Dog;

				var lucy = new Dog();
				console.log(lucy.paws);//10
				console.log(lucy.hair);//false
				console.log(lucy.say());//dog!
				console.log(lucy.constructor);//function Dog()
		</script>
	</section>
	<hr>

	<section>
		<h3>为什么要使用原型</h3>
		<p>原型包含可以由特定类型的所有实例共享的属性和方法,实现代码重用，减少内存占用。</p>
	</section>
	<hr>

	<section>
		<h3>怎么使用原型</h3>
		<h4>1.使用思路</h4>
		<p>首先理清原型链，然后确定行为----确定角色，谁是儿子（实例对象），谁是爸爸（原型对象，（是否被重写）），谁是中介（构造函数），然后确定行为，是儿子委托中介找爸爸，还是爸爸定位中介，儿子定位中介，还是对角色进行操作</p>
		<h4>2.prototype属性的相关方法</h4>
		<pre>
			for-in循环枚举属性
			isPrototypeOf()：用来判断某个proptotype对象和某个实例之间的关系
			hasOwnProperty()：用来判断某一个属性到底是本地属性，还是继承自prototype对象的属性
			in运算符：用来判断，某个实例是否含有某个属性，不管是不是本地属性

		</pre>
		<script>
			var o={p1:1,p2:2};
			for (var i in o){
				console.log(o[i]);
			}

			function Person(name,age){
					this.name=name;
					this.age=age;
			}
			Person.prototype.job="Software Engineer";
			Person.prototype.sayName=function(){
				console.log(this.name);
			}
			var p1=new Person("张三",15);
			var p2=new Person("李四",20);
			
			console.log(Person.prototype.isPrototypeOf(p1));//true
			console.log(p1.hasOwnProperty("name"));//true
			console.log(p1.hasOwnProperty("job"));//false
			console.log("name" in p1);//true
			console.log("job" in p1);//true
		</script>
		<h4 name="exBnObj" id="exBnObj">3.扩展内建对象</h4>
		<p>实例：为String对象添加反转字符串的功能</p>
		<script>
			if(!String.prototype.reverse){
				String.prototype.reverse=function (){
					return Array.prototype.reverse.apply(this.split('')).join('');
				};
			}
			var str="olleH";
			console.log(str.reverse());
		</script>

		<h4>4.原型继承</h4>
		<script>
		//基于原型链的继承：（爸爸的属性和方法，都是借儿子用的，儿子本身并没有（假设不存在同名属性和方法的覆盖））
		//①原型继承函数：（三个构造函数Parent,Child,F）
			function extend(Child,Parent){
				var F=function (){};
				F.prototype=Parent.prototype;
				Child.prototype=new F();
				Child.prototype.constructor=Child;
				Child.uber=Parent.prototype;
			}
			function P(){}
			P.prototype.nmae="parent";
			P.prototype.showName=function(){return this.name;};

			function C(){}
			extend(C,P);
			//Object{constructor:P(),showname:(),name:"parent",__proto__:Object}
			console.log(P.prototype);
			//Object{constructor:C(),__proto__:Object}
			console.log(C.prototype);

		//②根据原型链直接在对象之间建立关联函数：（一个构造函数F）
			function object(o){
				var n=null;
				function F (){}
				F.prototype=o;
				n =new F();
				n.uber=o;
				return n;

			}	
			var p={
				name:'shape',
				showName:function(){return this.name;}
			}
			var c=object(p);

			//Object{constructor:P(),showname:(),name:"parent",__proto__:Object}
			console.log(p);
			//F{uber:Object,__proto__:Object}
			console.log(c);
		</script>
		<pre>
		基于原型链的继承：（爸爸的属性和方法，都是借儿子用的，儿子本身并没有（假设不存在同名属性和方法的覆盖））
		①原型继承函数：（三个构造函数Parent,Child,F）
			function extend(Child,Parent){
				var F=function (){};
				F.prototype=Parent.prototype;
				Child.prototype=new F();
				Child.prototype.constructor=Child;
				Child.uber=Parent.prototype;
			}
			
		②根据原型链直接在对象之间建立关联函数：（一个构造函数F）
			function object(o){
				var n=null;
				function F (){}
				F.prototype=o;
				n =new F();
				n.uber=o;
				return n;
			}	
		</pre>
		
		<script>
			//从误区到改进
			function Animals(){}
			Animals.prototype.name="animals";
			if(!Animals.prototype.eat){
				Animals.prototype.eat=function(){return "I Can eat!"};
			}
			
			function Cat(){}
		/*
			//误区1：直接把Cat.prototype=Animals.prototype,这样的机制出现了错误，因为这是一种原型的拷贝，也就是说Cat从Animals手上拿得指向权（通过Cat和Animals创建的实例，都指向了同一个原型对象），当子对象对原型进行了修改，父对象也会改变，这不符合继承的理念
			Cat.prototype=Animals.prototype;
			var cat1=new Cat();
			console.log(cat1.eat());//I Can eat!

			//Cat原型重写前对Animals进行实例化
			var a1=new Animals();
			console.log(a1.name);//animals

			//Cat原型重写后对Animals进行实例化
			Cat.prototype.name="cat";
			Cat.prototype.constructor=Cat;
			var a2=new Animals();
			console.log(a2.name);//cat
		*/
		/*
			//误区2：直接Cat.prototype= new Animals(),这里把Cat的原型作为构造器Animals的一个实例，虽然修改了上面的问题，也基本上满足你的需求，但Animals也会产生一些副作用（比如写日志，注册到其他对象，给this添加数据属性...都会影响Cat的后代）
			Cat.prototype= new Animals();
			Cat.prototype.constructor=Cat;
			var cat1=new Cat();
			console.log(cat1.eat());//I Can eat!

			//Cat原型重写前对Animals进行实例化
			var a1=new Animals();
			console.log(a1.name);//animals

			//Cat原型重写后对Animals进行实例化
			Cat.prototype.name="cat";
			var a2=new Animals();
			console.log(a2.name);//animals
		*/
		/*
			//改进：综合上面两种问题，我们可以通过引进一个临时的构造器函数F()来充当中介，具体实现是这样的，首先F从Animals手上拿得指向权，F.prototype=Animals.prototype，把Cat的原型作为一个构造器F的一个实例，这样既实现了继承，又清除了副作用。
			
			//创建中介F(),实现继承
			var F=function(){};
			F.prototype=Animals.prototype;
			Cat.prototype=new F();
			Cat.prototype.constructor=Cat;

			var cat1=new Cat();
			console.log(cat1.eat());//I Can eat!

			//Cat原型重写前对Animals进行实例化
			var a1=new Animals();
			console.log(a1.name);//animals

			//Cat原型重写后对Animals进行实例化
			Cat.prototype.name="cat";
			var a2=new Animals();
			console.log(a2.name);//animals
		*/
		/*
			//改进2:上面的方法基本实现了原型继承，但还可以在改进，例如当Animals和Cat的原型有同名方法时，如何访问Animals的方法呢？我们可以为Cat引入一个uber属性（随便起的，德语中super的同义词，因为super在JavaScript中是保留字），来获得Animals的指向权。即Cat.uber=Animals.prototype
			//创建中介F(),实现继承
			var F=function(){};
			F.prototype=Animals.prototype;
			Cat.prototype=new F();
			Cat.prototype.constructor=Cat;
			Cat.uber=Animals.prototype;

			var cat1=new Cat();
			console.log(cat1.constructor);//function Cat(){}
			console.log(cat1.uber);//undefined
			Cat.prototype.eat=function(){return "I can eat too!"};
			console.log(cat1.eat());//I can eat too!
			console.log(cat1.constructor.uber.eat());//I Can eat!
		*/
		
			//改进3：创建中介F(),实现继承，这一功能有很大的重用性，所以可以把继承部分封装成可反复重用的函数
			//继承函数extend(Child,Parent)
			function extend(Child,Parent){
				var F=function (){};
				F.prototype=Parent.prototype;
				Child.prototype=new F();
				Child.prototype.constructor=Child;
				Child.uber=Parent.prototype;
			}
			extend(Cat,Animals);
			

			var cat1=new Cat();
			Cat.prototype.eat=function(){return "I can eat too!"};
			console.log(cat1.eat());//I can eat too!
			console.log(cat1.constructor.uber.eat());//I Can eat!
		
			// 改进4：以上的继承都引入了多个构造器函数，但是由原型链我们得知，要在两个对象之间直接建立关联（继承），只需要一个构造函数就够了，而且这个构造函数还可以是临时的中介F().
			function object(o){
				var n=null;
				function F (){}
				F.prototype=o;
				n =new F();
				n.uber=o;
				return n;

			}	
			var shape={
				name:'shape',
				showName:function(){
					console.log(this.name);
				}
			}
			var triangle=object(shape);
			//将triangle重写前
			console.log(triangle);
			triangle.showName();

			//重写后
			triangle.showName=function(){
				console.log('triangle');
			}
			triangle.showName();
			shape.showName();
		</script>
	</section>
	
	
	
	
</body>
</html>