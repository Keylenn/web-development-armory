
<!DOCTYPE HTML>
<html>
<head>
  <meta charset="UTF-8">
  <title>面向对象</title>
  <style type="text/css">
  	em{
  		color:red;
  		font-size:18px;
  	}
  	a{
  		text-decoration:none;
  		color:rgba(0,0,255,0.6);
  	}
  </style>
</head>
<body>
	<section>
			<h3>什么是面向对象</h3>
			<h4>1.相关概念</h4>
			<p>①对象是无序属性的集合，其属性可以包括基本值，对象或者函数,也就是一组<em>名值对的无序集合</em>(与数组类似但 <em>键值类型可以自定义</em> )；通过一种叫做<a href="#prototype"name="b1" id="b1">原型（prototype）</a>的方式来实现面向对象编程</p>
			<p>②对象是一个整体，对外提供一些操作，使用对象时，只关注对象提供的功能，不关注其内部的细节。例子：收音机、JQuery</p>
			<p>③ECMAScript提供了 6 种<a href="#dataType" name="b2" id="b2">数据类型</a>,但是为了实现面向对象，ECMAScript设计出了一种非常成功的数据结构 - JSON(JavaScript Object Notation), 这一经典结构已经可以脱离语言而成为一种广泛应用的数据交互格式</p>


			<h4>2.基于类的面向对象和基于原型的面向对象方式比较</h4>
			<p>在基于类的面向对象方式中，对象（object）依靠  <em>类（class）(工程图纸)</em>来产生 。而在基于原型的面向对象方式中，对象（object）则是依靠 <em>构造器（constructor）(工人和机器 )</em>利用<em> 原型（prototype）(各种零部件)</em>构造出来的。举个客观世界的例子来说明二种方式认知的差异。例如工厂造一辆车，一方面，工人必须参照一张工程图纸，设计规定这辆车应该如何制造。这里的工程图纸就好比是语言中的 类 (class)，而车就是按照这个 类（class）制造出来的；另一方面，工人和机器 ( 相当于 constructor) 利用各种零部件如发动机，轮胎，方向盘 ( 相当于 prototype 的各个属性 ) 将汽车构造出来。</p>
			<h4>（待整理）3.对象的特性（不可直接访问），也就是属性包含两种，数据属性和访问器属性</h4>
			<p>1)、数据属性</p>
		<pre>
			Configurable　　//表示能否通过delete删除，默认为true；
			Enumerable　　//表示能否通过for-in循环返回属性，默认为true;
			Writable　　　  //表示能否修改属性的值，默认为true;
			Value              //包含属性的数据值，默认为undefined
		</pre>
			<p>2)、访问器属性</p>
		<pre>
			Configurable
			enumerable
			get                //在读取属性时调用的函数
			set                //在写入属性时调用的函数
		</pre>
			<h4>4.对象组成</h4>
			<p>通常，在全局里定义的变量在对象里叫属性，而且属性可以是基本值，对象，数组，函数等；在全局里定义的函数在对象了叫方法</p>
		<pre>
			var person={
				name:'张三',
				age:15
			};
			①对象变量名person
			②{}----对象文本标识法法（[]---数组文本标识法）
			③当属性（属性名:属性值）不是最后一个时，属性之间用逗号（,）隔开
			通常情况下，属性名不加引号，除了以下情况：
			1）是保留字  'this':'this+1'
			2）包含空格或特殊字符  'yes or no':1
			3）以数字开头 '123s' :123
		</pre>
		<script>
			var person={
				name:'张三',
				age:15,
				talk:function(){
					console.log(this+"talk");
				},
				stu:{
					number:1234,
					study:function(){
						console.log(this+"study")
					}
				},
				identity:['student','children','father']
			};
			console.log(person);
		</script>
		<h4>5.易错解析</h4>
		<p>1）JavaScript一切皆是对象？</p>
		<p>要解决这个问题，需要对数据类型进行进一步分类，通过数据类型的值的功能作用分成<em>基本类型和引用类型（对象类型）</em>，基本类型包括Number, String, Boolean, null, undefined，引用类型包括<em> Object及其特殊的对象子类型（易称复杂的基本类型）（ Array、Function、String、Date、RegExp、Error）</em></p>
<p>根据这个分类,这个问题的简单答案是:JavaScript中，并非一切值都是对象。是只有属于对象类型的值才是对象。也可以认为，任何非基本类型的都是对象类型。两者主要有两个区别：<em>可变性和比较</em></p>
<pre> 
值类型VS值类型：
a、值类型
    对于值类型变量，变量的交换（将一个变量赋值给另一个变量）相当于是创建了一个新的空间，把原有的变量值复制一份，并将其存储在新空间当中，新空间与之前空间互不影响
    占用的空间固定，保存在栈中
    保存与复制是值本身
    使用typeof检测数据的类型（推荐使用这种办法判断基本数据类型）
    基本数据类型是值类型（数值、布尔值、null、undefined、字符串）
        
b、值类型
    引用类型变量的交换，并不会创建一个新的空间，而是让新变量和之前的变量，同时指向一个原有空间（即同一个地址）。可以理解为C语言的指针。以生活的实例来说，就如同原来一个人有家门的钥匙，
    之后这个人结婚了，配了一把钥匙给自己的妻子，这时候，两个人共同有家的钥匙，但是家还是一个家。
    占用空间不固定，保存在堆中
    保存与复制指向对象中的一个指针
    使用instanceof检测数据的类型（推荐使用这种方法判断引用类型）
    使用new（）方法构造出的对象是引用型
</pre>
		<script>
			//可变性（添加、删除属性）
			var str1="Type";
			//str1.name="baseType";
			console.log(str1.name);//undefined ，TypeError: can't assign to properties of (new String("Type")): not an object

			var arr1=[];
			arr1.name="student";
			console.log(arr1.name);//student

			//比较和传递（基本类型通过值来比较和传递，而对象类型通过引用来比较和传递）
			var s1="a",s2="a";
			console.log(s1===s2);//true
			var s3="a",s4;
			s4=s3;
			s4="b";
			console.log(s3===s4);//false

			var o1={name:"a"},o2={name:"a"};
			console.log(o1===o2);//false
			var o1={name:"a"},o2={name:"b"};
			o2=o1;
			console.log(o1===o2);//true
		</script>
		<p>基本类型如果不是对象，为什么我们可以调用他们的属性和方法呢？---包装对象</p>
		<p>JavaScript中有一些特殊的对象子类型常被称为原生对象（本地对象的一种）(实际上是一些内置的构造函数)，当你尝试调用基本类型的方法，JavaScript在幕后做了一个巧妙的处理，将你的基本类型的值转换成临时对象用于构造函数，决定使用哪个构造函数取决于你尝试改变的基本类型的值，在String中调用.length会使用string()构造函数临时将基本类型转变成对象—允许你使用length方法而改变它，这个临时对象被称为包装对象。有趣的是，null和undefined这两个基本类型不能调用这样的方法，否则会提示类型错误。</p>
		<p>当我们尝试在基本类型的值中调用属性或方法时，JavaScript使用包装对象来临时控制基本类型，导致对象变为只读的并在垃圾回收后执行</p>
		<script>
			var str2="helloworld";
			//str2.length=10;//TypeError: "length" is read-only
			console.log(str2.length);//5,当执行此句时，因为尝试调用只读属性length，length会使用string()构造函数临时将基本类型转变成包装对象，这个包装对象是临时的，语句执行结束即变成基本类型
			console.log(typeof str2);//string

			var str3=str2.substr(0,5);
			console.log(str3);//hello

			var str4=new String(str2);
			console.log(str4);//String { "helloworld", 等 11 项… }
		</script>
		<p>2）宿主对象、<em>原生对象、内置对象</em>、本地对象</p>
		<pre>
		①宿主对象：DOM和BOM
			宿主环境：一般宿主环境由外壳程序创建与维护，只要能提供js引擎执行的环境都可称之为外
			壳程序。如：web浏览器，一些桌面应用系统等。即由web浏览器或是这些桌面应用系统早就的
			环境即宿主环境。
			由ECMAScript实现的宿主环境提供的对象，可以理解为：浏览器提供的对象。所有的BOM和DOM
			都是宿主对象。

		②原生对象：独立于宿主环境的 ECMAScript 实现提供的对象（new后的对象）
			Object、Function、Array、String、Boolean、Number、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError

		③内置对象（不需要new， 直接引用——只有Math Global)
			Global对象是ECMAScript中最特别的对象，因为实际上它根本不存在(只是一个概念)，但大家
			要清楚，在ECMAScript中，不存在独立的函数，所有函数都必须是某个对象的方法。类似于isN
			aN()、parseInt()和parseFloat()方法等，看起来都是函数，而实际上，它们都是Global对象的方法。

		其中，原生对象和内置对象都是本地对象，即ECMAScript内部的对象，JS中，可以大致地将对象分为本地对象，宿主对象和自定义对象。

		</pre>
	</section>
	<hr>

	<section>
		<h4>为什么要使用面向对象</h4>
		<p> OOP中通过抽象、封装、继承（多重继承和多态）来加强代码可读性、可维护性、可扩展性，通过对客观世界的抽象让代码活起来。</p>
	</section>
	<hr>

	<section>
		<h3>怎么使用面向对象</h3>
		<h4>1.创建对象</h4>
		<p>1).工厂模式</p>
		<p>考虑到在ECMAScript中无法创建类，开发人员就发明了一种函数，用<em>函数来封装以特定接口创建对象的细节</em></p>
		<script type="text/javascript">
			function createPerson(name,age,job){
				var o=new Object();
				o.name=name;
				o.age=age;
				o.job=job;
				o.sayName=function(){
					//console.log(this==person);
					console.log(this.name);
				};
				return o;
			}
			var person  = createPerson("张三",15,'Software Engineer');//不需要使用new
			person.sayName();
		</script>
		<p>函数createPerson()能够根据接受的参数来构建一个包含所有必要信息的Person对象。可以无数次地调用这个函数，而每次它都会返回一个包含三个属性一个方法的对象。工厂模式虽然解决了创建多个相似对象的问题，但无法确定对象的类型（因为都是Object）,而且创建的多个对象之间没有关联</p>
		
		<p>2).<a href="#constructor" id="b3" name="b3">构造函数</a>模式</p>
		<p>ECMAScript中的构造函数可用来创建特定类型的对象。像Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。例如，可以使用构造函数模式将前面的例子重写</p>
		<script type="text/javascript">
			function Person(name,age,job){
				this.name=name;
				this.age=age;
				this.job=job;
				this.sayName=function(){
					console.log(this.name);
				}
			}
			var person1=new Person("张三",15,'Software Engineer');
			console.log(person1 instanceof Object && person1 instanceof Person );
			var person2=new Person("李四",20,'Doctor');
			person1.sayName();
			person2.sayName();
		</script>
		<p>在这个例子中，Person()函数取代了createPerson()函数。我们注意到，Person()中的代码除了与createPerson()中相同的部分外，还存在以下不同之处：<em>没有显式地创建对象</em>； 直接将属性和方法赋给了this对象;<em>没有return语句</em>。此外，还应该注意到函数名Person使用的是大写字母P。按照惯例，<em>构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。</em>这个做法借鉴自其他OO语言，主要是为了区别于ECMAScript中的其他函数；因为构造函数本身也是函数，只不过可以用来创建对象而已。<em>要创建Person的新实例，必须使用new操作符</em>。
		<p>在前面例子的最后，person1和person2分别保存着Person的一个不同的实例。这两个对象都有一个<em>constructor（构造函数）属性，该属性指向Person</em>
			，如下所示。对象的constructor属性最初是用来标识对象类型的。但是，提到检测对象类型，还是instanceof操作符要更可靠一些。我们在这个例子中创建的所有对象既是Object的实例，同时也是Person的实例</p>
		<p>创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而这正是构造函数模式胜过工厂模式的地方。在这个例子中，person1和person2之所以同时是Object的实例，是因为所有对象均继承自Object（详细内容稍后讨论）。以这种方式定义的构造函数是定义在Global对象（在浏览器中是window对象）中的。</p>

		<p>3).原型模式</p>
		<p>使用构造函数的主要问题，就是多个实例重复创建方法，无法共享，多个实例都有sayName方法，但均不是同一个Function的实例，另外在全局作用域中定义的函数实际上只能被某个对象调用，这让全局作用域有点名不副实。而更让人无法接受的是：如果对象需要定义很多方法，那么就要定义很多个全局函数</p>
		<script>	
			function Person(){}
			Person.prototype.name="张三";
			Person.prototype.age="15";
			Person.prototype.job="Software Engineer";
			Person.prototype.sayName=function(){
				console.log(this.name);
			}
			var p1=new Person();
			var p2=new Person();
			console.log(p1.age);//15
			p2.sayName();//张三
			console.log(p1.sayName===p2.sayName);//true
		</script> 
		<p>4).组合使用构造函数模式和原型模式<em>(推荐使用)</em></p>
		<p>原型模式虽然可以让所有对象实例共享它所包含的属性和方法,但是无法传入参数，不能初始化属性值，而且如果包含引用类型的值时，改变其中一个实例的值，则会在所有实例中体现，因此推荐组合使用构造函数模式和原型模式来创建对象</p>
		<script>
		function Person(name,age,job){
			this.name=name;
			this.age=age;
			this.job=job;
		}
		Person.prototype.sayName=function(){
			console.log(this.name);
		}
		var per1=new Person("张三",15,'Software Engineer');
		var per2=new Person("李四",20,'Doctor');
		per1.sayName();//张三
		per2.sayName();//李四
		console.log(per1.sayName===per2.sayName);//true
		</script>
		<h4>2.封装</h4>
		<p>封装只有两种状态，一种是公开的，一种是私有的，其实封装就是根据需要把数据被保护在内部，程序的其它部分只有通过被授权的操作(成员方法)，才能对数据进行操作</p>
		<script>
			function Person(name,age,job){
				//公开：
				this.name=name;
				this.age=age;
				this.job=job;
				//私有
				var name="人类"
				var sayName=function(){
					console.log(name);
				};
			}
			Person.prototype.sayName=function(){
				console.log(this.name);
			}
			var per1=new Person("张三",15,'Software Engineer');
			var per2=new Person("李四",20,'Doctor');
			per1.sayName();//张三
			per2.sayName();//李四
			console.log(per1.sayName===per2.sayName);//true
		</script>
		<h4>3.继承----<a href="objInheritExample.html" target="_blank">案例应用</a></h4>
		<p>由于JavaScript没有关于继承的直接说法，所以有很多人从不同角度出发，创建了多种多样的继承机制。所以继承的学习关键在于原理，那么如何实现继承呢，学习了这些原理，我们可以根据需求适当的引进一些方法（call()、apply()等），将方法和原理结合起来，创建适合你需求的继承机制。</p>
		<p>1）原理1：基于原型链的继承</p>
		<pre>
		基于原型链的继承：（爸爸的属性和方法，都是借儿子用的，儿子本身并没有（假设不存在同名属性和方法的覆盖））
		①原型继承函数：（三个构造函数Parent,Child,F）
			function extend(Child,Parent){
				var F=function (){};
				F.prototype=Parent.prototype;
				Child.prototype=new F();
				Child.prototype.constructor=Child;
				Child.uber=Parent.prototype;
			}
			
		②根据原型链直接在对象之间建立关联函数：（一个构造函数F）
			function object(o){
				var n=null;
				function F (){}
				F.prototype=o;
				n =new F();
				n.uber=o;
				return n;
			}	
															<a href="prototype.html" target="_blank">--实现</a>
		</pre>
		<p>2）原理2：基于属性拷贝的继承</p>
		<pre>
		基于属性拷贝的继承（爸爸的属性和方法，通过拷贝让儿子也拥有一份（假设不存在同名属性和方法的覆盖））
		深层拷贝（在JQuery中被广泛引用）：
			function deepCopy(p,c){
				var c=c||{};
				for(i in p){
					if(typeof p[i]==='object'){
						//初始化c[i]
						c[i]=(p[i].constructor===Array )? [] : {};
						//再执行一次拷贝
						deepCopy(p[i],c[i])
					}
					else{
						c[i]=p[i];
					}
				}
				return c;
			}
		</pre>
		<script>
		/*
			//误区：将爸爸的属性通过循环拷贝给儿子，如果儿子的引用类型被修改的话（通过方法），就会影响到爸爸的属性，这种属性拷贝叫浅拷贝，在拷贝引用类型时只是拷贝了该对象在内存的位置指针。（复制了钥匙，获得了爸爸房子的使用权），这种方式不符合继承的理念。
			function shallowCopy(p){
				var c={};
				for(var i in p){
					c[i]=p[i];
				}
				c.uber=p;
				return c;
			}
			var p={
				name:'parent',
				arr:[1,2,3]
			}
			var c=shallowCopy(p);

			//Object{arr:Array[3],name:"parent",__proto__:Object}
			console.log(p);
			//Object{arr:Array[3],name:"parent",__proto__:Object,uber:Object}
			console.log(c);

			//儿子的基本类型属性的重写不影响爸爸，但是引用类型就可能影响了，当儿子的引用类型重写属性倒不会有什么问题，但是当通过方法修改属性的话，就会影响到爸爸了。
			
			//重写基本类型
			c.name="child";
			console.log(c.name)//child
			console.log(p.name)//perent

			//修改属性,p.arr受影响，因为两个属性引用的是同一个数组（拿着钥匙进你爸的房子进行修改）
			c.arr.push(4,5,6);
			console.log(c.arr)//[1, 2, 3, 4, 5, 6]
			console.log(p.arr)//[1, 2, 3, 4, 5, 6]

			//重写引用类型的属性（修改自己家的房子）
			c.arr=[7,8,9];
			console.log(c.arr)//[7, 8, 9]
			console.log(p.arr)//[1, 2, 3, 4, 5, 6]
		*/	
			//改进：要改变上面的在拷贝引用类型时只是拷贝了该对象在内存的位置指针，我们可以进行一次判断，当拷贝的是引用类型的属性时，再执行一次拷贝，拷贝引用类型里的所有属性。即这一次不是拷贝钥匙，而是拷贝整个房子。
			function deepCopy(p,c){
				var c=c||{};
				for(i in p){
					if(typeof p[i]==='object'){
						//初始化c[i]
						c[i]=(p[i].constructor===Array )? [] : {};
						//再执行一次拷贝
						deepCopy(p[i],c[i])
					}
					else{
						c[i]=p[i];
					}
				}
				return c;
			}
			var p={
				name:'parent',
				arr:[1,2,3]
			}
			var c=deepCopy(p);
			//Object{arr:Array[3],name:"parent",__proto__:Object}
			console.log(p);
			//Object{arr:Array[3],name:"parent",__proto__:Object,uber:Object}
			console.log(c);

			//重写基本类型
			c.name="child";
			console.log(c.name)//child
			console.log(p.name)//perent

			//修改属性
			c.arr.push(4,5,6);
			console.log(c.arr)//[1, 2, 3, 4, 5, 6]
			console.log(p.arr)//[1, 2, 3]

			//重写引用类型的属性
			c.arr=[7,8,9];
			console.log(c.arr)//[7, 8, 9]
			console.log(p.arr)//[1, 2, 3]

		</script>
	</section>
	<hr>


<section>
	<h3>相关知识</h3>
	<pre name="prototype" id="prototype">
		原型：
			对象有一个特殊的[[prototype]]内置属性，<em>几乎（有为空的情况）</em>所有的对象在创建时都被赋予一个非空的值，指向对象的原型	

			原型对象有”constructor”属性，指向创建所有指向该原型的实例的构造函数
			但是这个属性并不可靠，当对象被重写时，”constructor”属性会发生变化

			原型链
			因为每个对象和原型都有原型，对象的原型指向原型对象，
			而父的原型又指向父的父，这种原型层层连接起来的就构成了原型链。
											<a href="#b1">--返回</a>
											<a href="prototype.html" target="_blank">--更多</a>
	</pre>
	<pre name="dataType" id="dataType">
		数据类型:
			ECMAScript提供了 6 种数据类型，即Boolean、Number、String、Null、Undefined、Object
			
			Undefined VS Null

			typeof VS instanceof
											<a href="#b2">--返回</a>
											<a href="dataType.html" target="_blank">--更多</a>
	</pre>
	<pre name="constructor" id="constructor">
		构造函数：
			当任意一个普通函数用于创建一类对象时，它就被称作构造函数，或构造器。例如：new String(“a string”)，调用内置的String函数构造了一个字符串对象

			执行var o2 = new CO();创建对象的时候，发生了四件事情：
			var o2  ={};
			o2.__proto__ = CO.prototype;
			CO.call(o2);
			return o2;

			在new表达式中，起初始化对象作用的只能是构造函数本身
											<a href="#b3">--返回</a>
											<a href="constructor.html" target="_blank">--更多</a>
	</pre>
</section>

</body>
</html>
